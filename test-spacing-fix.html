<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>行距修复测试</title>
    <link rel="stylesheet" href="static/css/styles.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
            line-height: 1.6;
        }
        
        .test-section {
            margin: 2rem 0;
            padding: 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
        }
        
        .batch-indicator {
            background: #f3f4f6;
            padding: 0.5rem 1rem;
            margin: 1rem 0;
            border-radius: 0.25rem;
            font-weight: bold;
            color: #374151;
            text-align: center;
        }
        
        .add-content-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.875rem;
            margin: 0.5rem;
        }
        
        .add-content-btn:hover {
            background: #2563eb;
        }
        
        .fix-indicator {
            background: #dcfce7;
            border: 1px solid #bbf7d0;
            color: #166534;
            padding: 0.75rem;
            border-radius: 0.375rem;
            margin: 1rem 0;
        }
    </style>
</head>
<body>
    <h1>🔧 行距修复测试</h1>
    
    <div class="fix-indicator">
        ✅ <strong>修复内容：</strong>
        <br>1. 移除了 new-content-block 动画类中的 transform: translateY 属性，现在只使用 opacity 过渡
        <br>2. 统一了动态列表的CSS类，从 my-4 改为 prose-list，确保与 prose 样式一致
        <br>3. 添加了调试工具，可以在实际页面中检测第16-17块间距问题
        <br>4. 在页面中添加右上角红色"调试间距"按钮，点击可以看到每个块的编号和间距测量
    </div>
    
    <div class="test-section">
        <h2>模拟有序列表分批加载</h2>
        <p>点击按钮模拟分批加载内容，观察列表项之间的间距是否正常：</p>
        
        <button class="add-content-btn" onclick="addFirstBatch()">添加第一批 (1-3)</button>
        <button class="add-content-btn" onclick="addSecondBatch()">添加第二批 (4-6)</button>
        <button class="add-content-btn" onclick="addThirdBatch()">添加第三批 (7-9)</button>
        <button class="add-content-btn" onclick="resetTest()">重置测试</button>
        
        <div id="testContent"></div>
    </div>
    
    <div class="test-section">
        <h2>修复前后对比</h2>
        
        <h3>修复前的问题：</h3>
        <ul>
            <li>新内容有 <code>transform: translateY(20px)</code> 动画</li>
            <li>动画执行期间会影响元素的垂直位置</li>
            <li>造成第一批和第二批内容之间的视觉间距异常</li>
            <li>列表续接时出现明显的断层感</li>
        </ul>
        
        <h3>修复后的改进：</h3>
        <ul>
            <li>移除了影响布局的 transform 动画</li>
            <li>只保留 opacity 过渡，不影响文档流</li>
            <li>所有渲染函数使用统一的动画逻辑</li>
            <li>内容间距保持自然和一致</li>
        </ul>
    </div>

    <script>
        function addFirstBatch() {
            const content = document.getElementById('testContent');
            const batchDiv = document.createElement('div');
            batchDiv.innerHTML = `
                <div class="batch-indicator">第一批内容</div>
                <ol class="my-4 list-decimal ml-6" start="1">
                    <li class="new-content-block">第一个列表项</li>
                    <li class="new-content-block">第二个列表项</li>
                    <li class="new-content-block">第三个列表项</li>
                </ol>
            `;
            content.appendChild(batchDiv);
            
            // 触发动画
            setTimeout(() => {
                batchDiv.querySelectorAll('.new-content-block').forEach(el => {
                    el.classList.add('new-content-show');
                });
            }, 50);
        }
        
        function addSecondBatch() {
            const content = document.getElementById('testContent');
            const lastOl = content.querySelector('ol:last-of-type');
            
            if (lastOl) {
                // 续接现有列表
                const newItems = `
                    <li class="new-content-block">第四个列表项（续接）</li>
                    <li class="new-content-block">第五个列表项（续接）</li>
                    <li class="new-content-block">第六个列表项（续接）</li>
                `;
                lastOl.insertAdjacentHTML('beforeend', newItems);
                
                // 添加批次指示器
                const indicator = document.createElement('div');
                indicator.className = 'batch-indicator';
                indicator.textContent = '第二批内容（续接到现有列表）';
                lastOl.insertAdjacentElement('afterend', indicator);
            } else {
                // 如果没有现有列表，创建新的
                const batchDiv = document.createElement('div');
                batchDiv.innerHTML = `
                    <div class="batch-indicator">第二批内容</div>
                    <ol class="my-4 list-decimal ml-6" start="4">
                        <li class="new-content-block">第四个列表项</li>
                        <li class="new-content-block">第五个列表项</li>
                        <li class="new-content-block">第六个列表项</li>
                    </ol>
                `;
                content.appendChild(batchDiv);
            }
            
            // 触发动画
            setTimeout(() => {
                content.querySelectorAll('.new-content-block:not(.new-content-show)').forEach(el => {
                    el.classList.add('new-content-show');
                });
            }, 50);
        }
        
        function addThirdBatch() {
            const content = document.getElementById('testContent');
            const lastOl = content.querySelector('ol:last-of-type');
            
            if (lastOl) {
                // 续接现有列表
                const newItems = `
                    <li class="new-content-block">第七个列表项（续接）</li>
                    <li class="new-content-block">第八个列表项（续接）</li>
                    <li class="new-content-block">第九个列表项（续接）</li>
                `;
                lastOl.insertAdjacentHTML('beforeend', newItems);
                
                // 添加批次指示器
                const indicator = document.createElement('div');
                indicator.className = 'batch-indicator';
                indicator.textContent = '第三批内容（续接到现有列表）';
                lastOl.insertAdjacentElement('afterend', indicator);
            } else {
                // 如果没有现有列表，创建新的
                const batchDiv = document.createElement('div');
                batchDiv.innerHTML = `
                    <div class="batch-indicator">第三批内容</div>
                    <ol class="my-4 list-decimal ml-6" start="7">
                        <li class="new-content-block">第七个列表项</li>
                        <li class="new-content-block">第八个列表项</li>
                        <li class="new-content-block">第九个列表项</li>
                    </ol>
                `;
                content.appendChild(batchDiv);
            }
            
            // 触发动画
            setTimeout(() => {
                content.querySelectorAll('.new-content-block:not(.new-content-show)').forEach(el => {
                    el.classList.add('new-content-show');
                });
            }, 50);
        }
        
        function resetTest() {
            document.getElementById('testContent').innerHTML = '';
        }
    </script>
</body>
</html> 